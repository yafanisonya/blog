(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{404:function(e,a,t){"use strict";t.r(a);var n=t(55),r=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"类数组转换数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类数组转换数组"}},[e._v("#")]),e._v(" 类数组转换数组")]),e._v(" "),t("p",[t("strong",[e._v("类数组")])]),e._v(" "),t("ul",[t("li",[e._v("用 getElementsByTagName/ClassName()获得的 HTMLCollection")]),e._v(" "),t("li",[e._v("用 querySelector 获得的 nodeList")])]),e._v(" "),t("blockquote",[t("p",[e._v("转换成数组")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Array.prototype.slice.call()\nArray.from()\n\n\n[...arguments]     // ES6展开运算符\n Array.prototype.concat.apply([], arguments);\n")])])]),t("h2",{attrs:{id:"判断数组中是否包含某个值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#判断数组中是否包含某个值"}},[e._v("#")]),e._v(" 判断数组中是否包含某个值")]),e._v(" "),t("blockquote",[t("p",[e._v("indexOf、include、find、findIndex")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var arr=[1,2,3,4];\n\narray.indexOf\n// 判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回-1\n\narray.includes(searcElement[,fromIndex])\n// 判断数组中是否存在某个值，如果存在返回true，否则返回false\n\narray.find(callback[,thisArg])\n// 返回数组中满足条件的第一个元素的值，如果没有，返回undefined\n\narray.findIndex(callback[,thisArg])\n// 返回数组中满足条件的第一个元素的下标，如果没有找到，返回-1\n")])])]),t("h2",{attrs:{id:"对象转原始类型流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象转原始类型流程"}},[e._v("#")]),e._v(" 对象转原始类型流程")]),e._v(" "),t("blockquote",[t("p",[e._v("对象转原始类型，会调用内置的[ToPrimitive]函数")])]),e._v(" "),t("ul",[t("li",[e._v("如果 Symbol.toPrimitive()方法，优先调用再返回")]),e._v(" "),t("li",[e._v("调用 valueOf()，如果转换为原始类型，则返回")]),e._v(" "),t("li",[e._v("调用 toString()，如果转换为原始类型，则返回")]),e._v(" "),t("li",[e._v("如果都没有返回原始类型，会报错")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var obj = {\n  value: 3,\n  valueOf() {\n    return 4;\n  },\n  toString() {\n    return '5'\n  },\n  [Symbol.toPrimitive]() {\n    return 6\n  }\n}\nconsole.log(obj + 1); // 输出7\n")])])]),t("blockquote",[t("p",[e._v("如何让 if(a == 1 && a == 2)条件成立？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var a = {\n  value: 0,\n  valueOf: function() {\n    this.value++;\n    return this.value;\n  }\n};\nconsole.log(a == 1 && a == 2);//true\n")])])]),t("h2",{attrs:{id:"generator"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator"}},[e._v("#")]),e._v(" Generator")]),e._v(" "),t("p",[t("strong",[e._v("异步编程")])]),e._v(" "),t("ul",[t("li",[e._v('function 关键字与函数名之间有一个星号 "*"')]),e._v(" "),t("li",[e._v("函数体内使用 yield 表达式，定义不同的内部状态 （可以有多个 yield）")]),e._v(" "),t("li",[e._v("直接调用 Generator 函数并不会执行，也不会返回运行结果，而是返回一个遍历器对象（Iterator Object）")]),e._v(" "),t("li",[e._v("依次调用遍历器对象的 next 方法，遍历 Generator 函数内部的每一个状态")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function * foo(){\n  yield 'status one'\n  return 'hello world'\n}\n\nlet iterator = foo()\n// value 表示返回值，done 表示遍历状态\niterator.next()    // {value: 'status one', done: false}\niterator.next()    // {value: 'hello world', done: true}\n\nfunction * foo2(){\n  console.log('111')\n  yield 100\n  console.log('222')\n  yield 200\n  console.log('333')\n  yield 300\n}\nconst generator = foo2()\ngenerator.next()   // {value: 100, done: false}\ngenerator.next()   // {value: 200, done: false}\ngenerator.next()   // {value: 300, done: false}\ngenerator.next()   // {value: undefined, done: true}\n")])])]),t("h2",{attrs:{id:"async、await"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async、await"}},[e._v("#")]),e._v(" async、await")]),e._v(" "),t("p",[e._v("Generator 函数的语法糖：将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await\nasync 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("async function getStockPriceByName(name) {\n  const symbol = await getStockSymbol(name);\n  const stockPrice = await getStockPrice(symbol);\n  return stockPrice;\n}\n\ngetStockPriceByName('goog').then(function (result) {\n  console.log(result);\n});\n")])])]),t("h2",{attrs:{id:"proxy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#proxy"}},[e._v("#")]),e._v(" Proxy")]),e._v(" "),t("ul",[t("li",[e._v("创建一个对象的代理，从而实现基本操作的拦截和自定义")]),e._v(" "),t("li",[e._v("get 方法用于拦截某个属性的读取操作")]),e._v(" "),t("li",[e._v("set 方法用来拦截某个属性的赋值操作")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const person = {\n  name: 'zce',\n  age: 20\n}\n\nconst personProxy = new Proxy(person,{\n  // 监视属性读取\n  get(target, property){\n    return property in target ? target[property] : 'default'\n  },\n  // 监视属性设置\n  set(target, property, value){\n    if(property === 'age'){\n      if(!Number.isInteger(value)){\n        throw new TypeError(`${value} is not an int`)\n      }\n    }\n    target[property] = value\n  }\n})\n\npersonProxy.gender = 'male'  // {name: 'zce', age: 20, gender: 'male'}\n")])])]),t("h2",{attrs:{id:"es6-新特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6-新特性"}},[e._v("#")]),e._v(" ES6 新特性")]),e._v(" "),t("ul",[t("li",[e._v("Let 声明的成员只会在所声明的块中生效，修复了变量声明提升现象")]),e._v(" "),t("li",[e._v("Const 要求声明同时赋值,过后不允许重新赋值")]),e._v(" "),t("li",[e._v("模版字符串：反引号包裹，允许换行")]),e._v(" "),t("li",[e._v("函数参数的默认值：一定是在形参列表的最后")]),e._v(" "),t("li",[e._v("箭头函数")]),e._v(" "),t("li",[e._v("Class：使用 class 关键字声明类；函数声明会提升， 类声明不会提升")]),e._v(" "),t("li",[e._v("Extends 继承 ： class Student extends Person{｝")]),e._v(" "),t("li",[e._v("Object.assign：对象的合并，将源对象的所有可枚举属性，复制到目标对象")]),e._v(" "),t("li",[e._v("Object.is：判断两个值是否是相同的值")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 数组解构\nconst arr = [1,2,3]\nconst [foo, bar, baz] = arr    // 1,2,3\n\n// 对象解构\nconst obj = {\n  name: 'zce'\n}\nconst { name } = obj\n\n// forof  可以解决 forEach 无法直接跳出循环的问题\nfor(const item of arr){\n  console.log(item)\n  if(item> 100){ break }\n}\n")])])]),t("h2",{attrs:{id:"数组高阶函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组高阶函数"}},[e._v("#")]),e._v(" 数组高阶函数")]),e._v(" "),t("blockquote",[t("p",[e._v("高阶函数：可以接收另一个函数作为参数或者返回值为一个函数")])]),e._v(" "),t("h3",{attrs:{id:"map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[e._v("#")]),e._v(" map")]),e._v(" "),t("p",[e._v("参数:接受两个参数，一个是回调函数，一个是回调函数的 this 值(可选)。\n其中，回调函数被默认传入三个值，依次为当前元素、当前索引、整个数组。")]),e._v(" "),t("ul",[t("li",[e._v("创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果")]),e._v(" "),t("li",[e._v("对原来的数组没有影响")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let nums = [1, 2, 3];\nlet obj = {val: 5};\nlet newNums = nums.map(function(item,index,array) {\n  return item + index + array[index] + this.val;\n  //对第一个元素，1 + 0 + 1 + 5 = 7\n  //对第二个元素，2 + 1 + 2 + 5 = 10\n  //对第三个元素，3 + 2 + 3 + 5 = 13\n}, obj);\nconsole.log(newNums);//[7, 10, 13]\n")])])]),t("h3",{attrs:{id:"reduce"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reduce"}},[e._v("#")]),e._v(" reduce")]),e._v(" "),t("ul",[t("li",[e._v("参数: 接收两个参数，一个为回调函数，另一个为初始值。回调函数中四个默认参数，依次为积累值、当前值、当前索引和整个数组。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let nums = [1, 2, 3];\n// 多个数的加和\nlet newNums = nums.reduce(function(preSum,curVal,currentIndex,array) {\n  return preSum + curVal;\n}, 0);\nconsole.log(newNums);//6\n\n // 不传默认值会自动以第一个元素为初始值，然后从第二个元素开始依次累计。\n")])])]),t("h3",{attrs:{id:"filter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#filter"}},[e._v("#")]),e._v(" filter")]),e._v(" "),t("p",[e._v("参数: 一个函数参数。这个函数接受一个默认参数，就是当前元素。这个作为参数的函数返回值为一个布尔类型，决定元素是否保留。\nfilter 方法返回值为一个新的数组，这个数组里面包含参数里面所有被保留的项。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let nums = [1, 2, 3];\n// 保留奇数项\nlet oddNums = nums.filter(item => item % 2);\nconsole.log(oddNums);\n")])])]),t("h3",{attrs:{id:"sort"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sort"}},[e._v("#")]),e._v(" sort")]),e._v(" "),t("p",[e._v("参数: 一个用于比较的函数，它有两个默认参数，分别是代表比较的两个元素。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let nums = [2, 3, 1];\n//两个比较的元素分别为a, b\nnums.sort(function(a, b) {\n  if(a > b) return 1;\n  else if(a < b) return -1;\n  else if(a == b) return 0;\n})\n")])])]),t("p",[e._v("当比较函数返回值大于 0，则 a 在 b 的后面，即 a 的下标应该比 b 大。\n反之，则 a 在 b 的后面，即 a 的下标比 b 小。\n整个过程就完成了一次升序的排列。")]),e._v(" "),t("p",[e._v("当比较函数不传时如何进行排序？")]),e._v(" "),t("p",[e._v("答案是将数字转换为字符串，然后根据字母 unicode 值进行升序排序，也就是根据字符串的比较规则进行升序排序。")])])}),[],!1,null,null,null);a.default=r.exports}}]);