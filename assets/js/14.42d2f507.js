(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{410:function(v,_,t){"use strict";t.r(_);var e=t(55),s=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"http-状态码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-状态码"}},[v._v("#")]),v._v(" HTTP 状态码")]),v._v(" "),t("ul",[t("li",[v._v("1xx: 表示目前是协议处理的中间状态，还需要后续操作")]),v._v(" "),t("li",[v._v("2xx: 表示成功状态")]),v._v(" "),t("li",[v._v("3xx: 重定向状态，资源位置发生变动，需要重新请求")]),v._v(" "),t("li",[v._v("4xx: 请求报文有误")]),v._v(" "),t("li",[v._v("5xx: 服务器端发生错误")])]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("状态码")]),v._v(" "),t("th",[v._v("含义")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("200")]),v._v(" "),t("td",[v._v("请求成功")])]),v._v(" "),t("tr",[t("td",[v._v("301")]),v._v(" "),t("td",[v._v("永久重定向")])]),v._v(" "),t("tr",[t("td",[v._v("302")]),v._v(" "),t("td",[v._v("临时重定向")])]),v._v(" "),t("tr",[t("td",[v._v("400")]),v._v(" "),t("td",[v._v("请求报文存在语法错误")])]),v._v(" "),t("tr",[t("td",[v._v("403")]),v._v(" "),t("td",[v._v("服务器禁止访问")])]),v._v(" "),t("tr",[t("td",[v._v("404")]),v._v(" "),t("td",[v._v("资源未找到")])]),v._v(" "),t("tr",[t("td",[v._v("500")]),v._v(" "),t("td",[v._v("服务器内部错误")])])])]),v._v(" "),t("h2",{attrs:{id:"常见请求方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见请求方法"}},[v._v("#")]),v._v(" 常见请求方法")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("方法")]),v._v(" "),t("th",[v._v("含义")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("GET")]),v._v(" "),t("td",[v._v("通常用来获取资源")])]),v._v(" "),t("tr",[t("td",[v._v("POST")]),v._v(" "),t("td",[v._v("提交数据，即上传数据")])]),v._v(" "),t("tr",[t("td",[v._v("HEAD")]),v._v(" "),t("td",[v._v("获取资源的元信息")])]),v._v(" "),t("tr",[t("td",[v._v("PUT")]),v._v(" "),t("td",[v._v("修改数据")])]),v._v(" "),t("tr",[t("td",[v._v("DELETE")]),v._v(" "),t("td",[v._v("删除资源")])]),v._v(" "),t("tr",[t("td",[v._v("CONNECT")]),v._v(" "),t("td",[v._v("建立连接隧道，用于代理服务器")])]),v._v(" "),t("tr",[t("td",[v._v("OPTIONS")]),v._v(" "),t("td",[v._v("列出可对资源实行的请求方法，用来跨域请求")])]),v._v(" "),t("tr",[t("td",[v._v("TRACE")]),v._v(" "),t("td",[v._v("追踪请求-响应的传输路径")])])])]),v._v(" "),t("h2",{attrs:{id:"get-和-post-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post-的区别"}},[v._v("#")]),v._v(" GET 和 POST 的区别")]),v._v(" "),t("blockquote",[t("p",[v._v("语义")])]),v._v(" "),t("ul",[t("li",[v._v("GET 用于获取资源，POST 用于提交资源。")])]),v._v(" "),t("blockquote",[t("p",[v._v("缓存")])]),v._v(" "),t("ul",[t("li",[v._v("GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置")]),v._v(" "),t("li",[v._v("GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留")])]),v._v(" "),t("blockquote",[t("p",[v._v("编码")])]),v._v(" "),t("ul",[t("li",[v._v("GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制")])]),v._v(" "),t("blockquote",[t("p",[v._v("参数")])]),v._v(" "),t("ul",[t("li",[v._v("GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息")]),v._v(" "),t("li",[v._v("GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有")]),v._v(" "),t("li",[v._v("GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的) - GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包")]),v._v(" "),t("li",[v._v("GET 在浏览器回退时是无害的，而 POST 会再次提交请求")]),v._v(" "),t("li",[v._v("GET 产生的 URL 地址可以被加入收藏栏，而 POST 不可以")])]),v._v(" "),t("h2",{attrs:{id:"http-1-0、1-1、2-0-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0、1-1、2-0-的区别"}},[v._v("#")]),v._v(" HTTP 1.0、1.1、2.0 的区别")]),v._v(" "),t("ul",[t("li",[v._v("1 和 1.0 相比，1.1 可以一次传输多个文件")]),v._v(" "),t("li",[v._v("http1.x 解析基于文本，http2.0 采用二进制格式，新增特性 多路复用、header 压缩、服务端推送(静态 html 资源)")])]),v._v(" "),t("blockquote",[t("p",[v._v("1.0 协议缺陷")])]),v._v(" "),t("ul",[t("li",[v._v("无法复用链接，完成即断开，重新慢启动和 TCP 3 次握手")]),v._v(" "),t("li",[v._v("head of line blocking: 线头阻塞，导致请求之间互相影响")])]),v._v(" "),t("blockquote",[t("p",[v._v("1.1 改进")])]),v._v(" "),t("ul",[t("li",[v._v("长连接(默认 keep-alive)，复用")]),v._v(" "),t("li",[v._v("host 字段指定对应的虚拟站点")]),v._v(" "),t("li",[v._v("新增功能: 断点续传、身份认证、状态管理、cache 缓存")])]),v._v(" "),t("blockquote",[t("p",[v._v("2.0")])]),v._v(" "),t("ul",[t("li",[v._v("多路复用")]),v._v(" "),t("li",[v._v("二进制分帧层: 应用层和传输层之间")]),v._v(" "),t("li",[v._v("首部压缩")]),v._v(" "),t("li",[v._v("服务端推送")])]),v._v(" "),t("h2",{attrs:{id:"http-和-https-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-和-https-区别"}},[v._v("#")]),v._v(" Http 和 Https 区别")]),v._v(" "),t("ul",[t("li",[v._v("HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头")]),v._v(" "),t("li",[v._v("HTTP 是不安全的，而 HTTPS 是安全的")]),v._v(" "),t("li",[v._v("HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443")]),v._v(" "),t("li",[v._v("HTTP 无法加密，而 HTTPS 对传输的数据进行加密")]),v._v(" "),t("li",[v._v("HTTP 无需证书，而 HTTPS 需要 CA 机构 wosign 的颁发的 SSL 证书")]),v._v(" "),t("li",[v._v("在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 的安全传输机制工作在传输层")])]),v._v(" "),t("h2",{attrs:{id:"http-缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存"}},[v._v("#")]),v._v(" HTTP 缓存")]),v._v(" "),t("p",[v._v("缓存策略: 可分为 强缓存 和 协商缓存")]),v._v(" "),t("p",[t("strong",[v._v("强缓存")])]),v._v(" "),t("p",[v._v("浏览器判断缓存是否过期，未过期时，直接使用强缓存")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("Expires ：设置过期时间（绝对时间），资源在过期后需要再次请求。受限于本地时间，如果修改了本地时间，可能会造成缓存失效。")])]),v._v(" "),t("li",[t("p",[v._v("Cache-control：max-age=3600 是设置过期时长（相对时间），跟本地时间无关")])])]),v._v(" "),t("blockquote",[t("p",[v._v("Cache-Control 的 max-age 优先级高于 Expires")])]),v._v(" "),t("p",[t("strong",[v._v("协商缓存")]),v._v("\n当缓存已经过期时，使用协商缓存")]),v._v(" "),t("ul",[t("li",[v._v("唯一标识方案： Etag(response 携带) & If-None-Match(request 携带，上一次返回的 Etag): 服务器判断资源是否被修改")])]),v._v(" "),t("blockquote",[t("p",[v._v("ETag 存储的是文件的特殊标识，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。")])]),v._v(" "),t("ul",[t("li",[v._v("最后一次修改时间：Last-Modified(response) & If-Modified-Since (request，上一次返回的 Last-Modified)\n"),t("ul",[t("li",[v._v("如果一致，则直接返回 304 通知浏览器使用缓存")]),v._v(" "),t("li",[v._v("如不一致，则服务端返回新的资源")])])])]),v._v(" "),t("blockquote",[t("p",[v._v("Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。")])]),v._v(" "),t("ul",[t("li",[v._v("Last-Modified 缺点：\n"),t("ul",[t("li",[v._v("周期性修改，但内容未变时，会导致缓存失效")]),v._v(" "),t("li",[v._v("最小粒度只到 s， s 以内的改动无法检测到")])])])]),v._v(" "),t("blockquote",[t("p",[v._v("Etag 的优先级高于 Last-Modified")])]),v._v(" "),t("h2",{attrs:{id:"tcp-三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-三次握手"}},[v._v("#")]),v._v(" TCP 三次握手")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://i.imgur.com/j4QQU4x.png",alt:"三次握手"}}),v._v("\n建立连接前，客户端和服务端需要通过握手来确认对方")]),v._v(" "),t("ul",[t("li",[v._v("客户端发送 syn(同步序列编号) 请求，进入 syn_send 状态，等待确认")]),v._v(" "),t("li",[v._v("服务端接收并确认 syn 包后发送 syn+ack 包，进入 syn_recv 状态")]),v._v(" "),t("li",[v._v("客户端接收 syn+ack 包后，发送 ack 包，双方进入 established 状态")])]),v._v(" "),t("h2",{attrs:{id:"tcp-四次挥手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-四次挥手"}},[v._v("#")]),v._v(" TCP 四次挥手")]),v._v(" "),t("ul",[t("li",[v._v("客户端 -- FIN --\x3e 服务端， FIN—WAIT")]),v._v(" "),t("li",[v._v("服务端 -- ACK --\x3e 客户端， CLOSE-WAIT")]),v._v(" "),t("li",[v._v("服务端 -- ACK,FIN --\x3e 客户端， LAST-ACK")]),v._v(" "),t("li",[v._v("客户端 -- ACK --\x3e 服务端，CLOSED")])]),v._v(" "),t("p",[v._v("刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：")]),v._v(" "),t("ol",[t("li",[v._v("第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。")]),v._v(" "),t("li",[v._v("第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。")]),v._v(" "),t("li",[v._v("第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。")]),v._v(" "),t("li",[v._v("第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态")]),v._v(" "),t("li",[v._v("服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。")])]),v._v(" "),t("h2",{attrs:{id:"tcp、-udp-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp、-udp-区别"}},[v._v("#")]),v._v(" TCP、 UDP 区别")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://i.imgur.com/FrK3YvC.png",alt:"区别"}})]),v._v(" "),t("ol",[t("li",[t("code",[v._v("TCP")]),v._v("向上层提供面向连接的可靠服务 ，"),t("code",[v._v("UDP")]),v._v("向上层提供无连接不可靠服务。")]),v._v(" "),t("li",[v._v("虽然 "),t("code",[v._v("UDP")]),v._v(" 并没有 "),t("code",[v._v("TCP")]),v._v(" 传输来的准确，但是也能在很多实时性要求高的地方有所作为")]),v._v(" "),t("li",[v._v("对数据准确性要求高，速度可以相对较慢的，可以选用"),t("code",[v._v("TCP")])])]),v._v(" "),t("h2",{attrs:{id:"浏览器本地存储各自优劣"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器本地存储各自优劣"}},[v._v("#")]),v._v(" 浏览器本地存储各自优劣")]),v._v(" "),t("p",[v._v("浏览器的本地存储主要分为 Cookie、WebStorage 和 IndexDB, 其中 WebStorage 又可以分为 localStorage 和 sessionStorage。")]),v._v(" "),t("blockquote",[t("p",[v._v("共同点: 都是保存在浏览器端、且同源的")])]),v._v(" "),t("blockquote",[t("p",[v._v("不同点")])]),v._v(" "),t("ol",[t("li",[t("p",[v._v("cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下 sessionStorage 和 localStorage 不会自动把数据发送给服务器，仅在本地保存。")])]),v._v(" "),t("li",[t("p",[v._v("存储大小限制也不同，")])])]),v._v(" "),t("ul",[t("li",[v._v("cookie 数据不能超过 4K，sessionStorage 和 localStorage 可以达到 5M")]),v._v(" "),t("li",[v._v("sessionStorage：仅在当前浏览器窗口关闭之前有效；")]),v._v(" "),t("li",[v._v("localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作持久数据；")]),v._v(" "),t("li",[v._v("cookie：只在设置的 cookie 过期时间之前有效，即使窗口关闭或浏览器关闭")])]),v._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[v._v("作用域不同")])]),v._v(" "),t("ul",[t("li",[v._v("sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；")]),v._v(" "),t("li",[v._v("localstorage：在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在")]),v._v(" "),t("li",[v._v("cookie: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在")])]),v._v(" "),t("h2",{attrs:{id:"跨域通信方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#跨域通信方式"}},[v._v("#")]),v._v(" 跨域通信方式")]),v._v(" "),t("ul",[t("li",[v._v("jsonp(利用 script 标签没有跨域限制的漏洞实现。缺点：只支持 GET 请求)")])]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("function jsonp(url, jsonpCallback, success) {\n  const script = document.createElement('script')\n  script.src = url\n  script.async = true\n  script.type = 'text/javascript'\n  window[jsonpCallback] = function(data) {\n    success && success(data)\n  }\n  document.body.appendChild(script)\n}\n")])])]),t("ul",[t("li",[t("p",[v._v("CORS(设置 Access-Control-Allow-Origin：指定可访问资源的域名)")])]),v._v(" "),t("li",[t("p",[v._v("postMessage(message, targetOrigin, [transfer])(HTML5 新增 API 用于多窗口消息、页面内嵌 iframe 消息传递),通过 onmessage 监听 传递过来的数据")])]),v._v(" "),t("li",[t("p",[v._v("Websocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案")])]),v._v(" "),t("li",[t("p",[v._v("Node 中间件代理")])]),v._v(" "),t("li",[t("p",[v._v("Nginx 反向代理")])]),v._v(" "),t("li",[t("p",[v._v("各种嵌套 iframe 的方式，不常用")])]),v._v(" "),t("li",[t("p",[v._v("日常工作中用的最对的跨域方案是 CORS 和 Nginx 反向代理")])])]),v._v(" "),t("h2",{attrs:{id:"websocket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[v._v("#")]),v._v(" Websocket")]),v._v(" "),t("p",[v._v("Websocket 是一个 持久化的协议， 基于 http ， 服务端可以 主动 push")]),v._v(" "),t("p",[v._v("兼容：")]),v._v(" "),t("ul",[t("li",[v._v("FLASH Socket")]),v._v(" "),t("li",[v._v("长轮询： 定时发送 ajax")]),v._v(" "),t("li",[v._v("long poll： 发送 --\x3e 有消息时再 response")])]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("var ws = new WebSocket(url)\nws.onerror = fn\nws.onclose = fn\nws.onopen = fn\nws.onmessage = fn\nws.send()\n")])])])])}),[],!1,null,null,null);_.default=s.exports}}]);