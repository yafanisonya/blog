(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{415:function(e,t,v){"use strict";v.r(t);var _=v(55),r=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"vue-2-生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-2-生命周期"}},[e._v("#")]),e._v(" Vue 2 生命周期")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://i.imgur.com/ATGMxLM.png",alt:"生命周期"}}),e._v("\n每个 Vue 实例在创建时都会经历从创建、初始化、编译模版、挂载 Dom -> 渲染、更新 -> 渲染、卸载等一系列过程，这就是 Vue 的生命周期。")]),e._v(" "),v("p",[e._v("vue 生命周期钩子，在某一阶段时去触发的函数，目的是为了完成一些动作或者事件")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("create 阶段：vue 实例被创建")]),e._v(" "),v("ul",[v("li",[e._v("beforeCreate: 创建前，此时 data 和 methods 中的数据都还没有初始化")]),e._v(" "),v("li",[e._v("created： 创建完成，属性已经绑定， 但还未生成真实 dom")])])]),e._v(" "),v("li",[v("p",[e._v("mount 阶段： vue 实例被挂载到真实 DOM 节点")]),e._v(" "),v("ul",[v("li",[e._v("beforeMount：模板编译/挂载之前")]),e._v(" "),v("li",[e._v("mounted: 组件已挂载，此时可以操作 Dom")])])]),e._v(" "),v("li",[v("p",[e._v("update 阶段：当 vue 实例里面的 data 数据变化时，触发组件的重新渲染")]),e._v(" "),v("ul",[v("li",[e._v("beforeUpdate updated")])])]),e._v(" "),v("li",[v("p",[e._v("destroy 阶段：vue 实例被销毁")]),e._v(" "),v("ul",[v("li",[e._v("beforeDestroy destroyed")])])])]),e._v(" "),v("blockquote",[v("p",[e._v("数据请求放在 mounted")])]),e._v(" "),v("h2",{attrs:{id:"vue-2-组件间通信方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-2-组件间通信方式"}},[e._v("#")]),e._v(" Vue 2 组件间通信方式")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("父子组件：使用「props / $emit」进行通信")])]),e._v(" "),v("li",[v("p",[e._v("爷孙组件：\na. 使用两次父子组件间通信来实现\nb. 使用「provide + inject」来通信")])]),e._v(" "),v("li",[v("p",[e._v("任意组件：使用 eventBus = new Vue() 来通信\na. 主要 API 是 eventBus.$on 和 eventBus.$emit\nb. 缺点是事件多了就很乱，难以维护")])]),e._v(" "),v("li",[v("p",[e._v("任意组件：使用 Vuex 通信（Vue 3 可用 Pinia 代替 Vuex）")])])]),e._v(" "),v("h2",{attrs:{id:"vuex"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[e._v("#")]),e._v(" Vuex")]),e._v(" "),v("p",[e._v("Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库")]),e._v(" "),v("p",[e._v("主要包括以下几个模块：")]),e._v(" "),v("ul",[v("li",[e._v("State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。")]),e._v(" "),v("li",[e._v("Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。")]),e._v(" "),v("li",[e._v("Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。")]),e._v(" "),v("li",[e._v("Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。")]),e._v(" "),v("li",[e._v("Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。")])]),e._v(" "),v("blockquote",[v("p",[e._v("Mutation 和 Action 为什么要分开？\n为了让代码更易于维护")])]),e._v(" "),v("h2",{attrs:{id:"vuerouter"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vuerouter"}},[e._v("#")]),e._v(" VueRouter")]),e._v(" "),v("p",[e._v("Vue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举。")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("mode")]),e._v(" "),v("ul",[v("li",[e._v("hash")]),e._v(" "),v("li",[e._v("history")])])]),e._v(" "),v("li",[v("p",[e._v("router-link：在不重新加载页面的情况下更改 URL")])]),e._v(" "),v("li",[v("p",[e._v("router-view：将显示与 url 对应的组件")])]),e._v(" "),v("li",[v("p",[e._v("跳转")])])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('this.$router.push()\n\n<router-link to=""></router-link>\n')])])]),v("blockquote",[v("p",[e._v("$route 和 $router 区别")])]),e._v(" "),v("ul",[v("li",[e._v("router 为 VueRouter 的实例，是一个全局路由对象，包含了路由跳转的方法（push,replace)、钩子函数等。")]),e._v(" "),v("li",[e._v("route 是路由信息对象，每一个路由都会有一个 route 对象，是一个局部对象，包含 path,params,hash,query,fullPath,matched,name 等路由信息参数。")])]),e._v(" "),v("blockquote",[v("p",[e._v("Hash 模式和 History 模式区别")])]),e._v(" "),v("ul",[v("li",[e._v("一个用的 Hash，一个用的 History API")]),e._v(" "),v("li",[e._v("一个不需要后端 nginx 配合，一个需要")])]),e._v(" "),v("h3",{attrs:{id:"导航守卫"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#导航守卫"}},[e._v("#")]),e._v(" 导航守卫")]),e._v(" "),v("p",[e._v("vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航\n全局守卫、路由守卫、组件守卫")]),e._v(" "),v("p",[e._v("全局守卫：")]),e._v(" "),v("ul",[v("li",[e._v("router.beforeEach 全局前置守卫")]),e._v(" "),v("li",[e._v("router.beforeResolve 全局解析守卫")]),e._v(" "),v("li",[e._v("router.afterEach 全局后置钩子")])]),e._v(" "),v("p",[e._v("路由独享守卫：beforeEnter")]),e._v(" "),v("p",[e._v("组件内的守卫：")]),e._v(" "),v("ul",[v("li",[e._v("beforeRouteEnter")]),e._v(" "),v("li",[e._v("beforeRouteUpdate")]),e._v(" "),v("li",[e._v("beforeRouteLeave")])]),e._v(" "),v("p",[e._v("导航守卫实现登录控制")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("router.beforeEach((to, from, next) => {\n  if (to.path === '/login')\n    return next()\n  if (to 是受控页面 && 没有登录)\n    return next('/login')\n\n  next()\n})\n")])])]),v("h2",{attrs:{id:"vue-2-双向绑定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-2-双向绑定"}},[e._v("#")]),e._v(" Vue 2 双向绑定")]),e._v(" "),v("p",[e._v("使用 v-model / .sync 实现，\n"),v("code",[e._v("v-model")]),e._v(" 是 v-bind:value 和 von:input 的语法糖")]),e._v(" "),v("ul",[v("li",[e._v("v-bind:value 实现了 data ⇒ UI 的单向绑定")]),e._v(" "),v("li",[e._v("v-on:input 实现了 UI ⇒ data 的单向绑定")]),e._v(" "),v("li",[e._v("加起来就是双向绑定了")])]),e._v(" "),v("p",[e._v("这两个单向绑定是如何实现？")]),e._v(" "),v("p",[e._v("a. 前者通过 Object.defineProperty API 给 data 创建 getter 和 setter，用于监听\ndata 的改变，data 一变就会安排改变 UI")]),e._v(" "),v("p",[e._v("b. 后者通过 template compiler 给 DOM 添加事件监听，DOM input 的值变了就\n会去修改 data。")]),e._v(" "),v("h2",{attrs:{id:"vue-3-proxy"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-proxy"}},[e._v("#")]),e._v(" Vue 3 Proxy")]),e._v(" "),v("ol",[v("li",[e._v("弥补 Object.defineProperty 的两个不足\n"),v("ul",[v("li",[e._v("动态创建的 data 属性需要用 Vue.set 来赋值，Vue 3 用了 Proxy 就不需要了")]),e._v(" "),v("li",[e._v("基于性能考虑，Vue 2 篡改了数组的 7 个 API，Vue 3 用了 Proxy 就不需要了")])])]),e._v(" "),v("li",[e._v("defineProperty 需要提前递归地遍历 data 做到响应式，而 Proxy 可以在真正用到\n深层数据的时候再做响应式（惰性）")])]),e._v(" "),v("h2",{attrs:{id:"vue-3-composition-api"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-composition-api"}},[e._v("#")]),e._v(" Vue 3 Composition API")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("Composition API 比 mixins、高阶组件、extends、Renderless Components 等更好，原因有三：")]),e._v(" "),v("ul",[v("li",[e._v("模版中的数据来源不清晰")]),e._v(" "),v("li",[e._v("命名空间冲突")]),e._v(" "),v("li",[e._v("性能")])])]),e._v(" "),v("li",[v("p",[e._v("更适合 TypeScript")])])]),e._v(" "),v("h2",{attrs:{id:"vue-3-对比-vue-2-改动"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-对比-vue-2-改动"}},[e._v("#")]),e._v(" Vue 3 对比 Vue 2 改动")]),e._v(" "),v("ol",[v("li",[e._v("createApp() 代替了 new Vue()")]),e._v(" "),v("li",[e._v("v-model 代替了以前的 v-model 和 .sync")]),e._v(" "),v("li",[e._v("根元素可以有不止一个元素")]),e._v(" "),v("li",[e._v("新增 Teleport 传送门")]),e._v(" "),v("li",[e._v("ref 属性支持函数")]),e._v(" "),v("li",[e._v("响应式原理改变: 使用 Proxy 取代 Object.defineProperty")]),e._v(" "),v("li",[e._v("生命周期\n"),v("ul",[v("li",[e._v("使用 setup 代替之前的 beforeCreate 和 created")]),e._v(" "),v("li",[e._v("destroyed 被改名为 unmounted")])])])])])}),[],!1,null,null,null);t.default=r.exports}}]);