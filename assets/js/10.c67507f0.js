(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{407:function(v,_,l){"use strict";l.r(_);var t=l(55),i=Object(t.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h2",{attrs:{id:"从输入-url-到展示的过程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#从输入-url-到展示的过程"}},[v._v("#")]),v._v(" 从输入 url 到展示的过程")]),v._v(" "),l("ul",[l("li",[v._v("DNS 域名解析")]),v._v(" "),l("li",[v._v("建立 TCP 连接")]),v._v(" "),l("li",[v._v("发送 HTTP 请求")]),v._v(" "),l("li",[v._v("服务器处理请求")]),v._v(" "),l("li",[v._v("返回响应结果")]),v._v(" "),l("li",[v._v("关闭 TCP 连接")]),v._v(" "),l("li",[v._v("浏览器渲染")])]),v._v(" "),l("h2",{attrs:{id:"浏览器渲染过程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染过程"}},[v._v("#")]),v._v(" 浏览器渲染过程")]),v._v(" "),l("ol",[l("li",[v._v("HTML 被 HTML 解析器解析成 DOM 树")]),v._v(" "),l("li",[v._v("CSS 被 css 解析器解析生成 样式树")]),v._v(" "),l("li",[v._v("结合 DOM 树和样式树，生成一棵渲染树(Render Tree)")]),v._v(" "),l("li",[v._v("生成布局（flow），即将所有渲染树的所有节点进行平面合成")]),v._v(" "),l("li",[v._v("将布局绘制（paint）在屏幕上")])]),v._v(" "),l("ul",[l("li",[l("p",[v._v("HTML parser --\x3e DOM Tree")]),v._v(" "),l("ul",[l("li",[v._v("标记化算法，进行元素状态的标记")]),v._v(" "),l("li",[v._v("dom 树构建")])])]),v._v(" "),l("li",[l("p",[v._v("CSS parser --\x3e Style Tree")]),v._v(" "),l("ul",[l("li",[v._v("解析 css 代码，生成样式树")])])]),v._v(" "),l("li",[l("p",[v._v("attachment --\x3e Render Tree")]),v._v(" "),l("ul",[l("li",[v._v("结合 dom 树 与 style 树，生成渲染树")])])]),v._v(" "),l("li",[l("p",[v._v("layout: 布局")])]),v._v(" "),l("li",[l("p",[v._v("GPU painting: 像素绘制页面")])])]),v._v(" "),l("h2",{attrs:{id:"浏览器下事件循环-event-loop"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#浏览器下事件循环-event-loop"}},[v._v("#")]),v._v(" 浏览器下事件循环(Event Loop)")]),v._v(" "),l("blockquote",[l("p",[v._v("事件循环是指\n执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表")])]),v._v(" "),l("ul",[l("li",[v._v("微任务 microtask(jobs): promise / ajax / Object.observe(该方法已废弃)")]),v._v(" "),l("li",[v._v("宏任务 macrotask(task): setTimout / script / IO / UI Rendering")])]),v._v(" "),l("h2",{attrs:{id:"内存泄露"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#内存泄露"}},[v._v("#")]),v._v(" 内存泄露")]),v._v(" "),l("ul",[l("li",[v._v("意外的全局变量: 无法被回收")]),v._v(" "),l("li",[v._v("定时器: 未被正确关闭，导致所引用的外部变量无法被释放")]),v._v(" "),l("li",[v._v("事件监听: 没有正确销毁 (低版本浏览器可能出现)")]),v._v(" "),l("li",[v._v("闭包: 会导致父级中的变量无法被释放")]),v._v(" "),l("li",[v._v("dom 引用: dom 元素被删除时，内存中的引用未被正确清空")])]),v._v(" "),l("blockquote",[l("p",[v._v("可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。")])]),v._v(" "),l("h2",{attrs:{id:"重绘与回流"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#重绘与回流"}},[v._v("#")]),v._v(" 重绘与回流")]),v._v(" "),l("p",[v._v("当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。")]),v._v(" "),l("p",[l("strong",[v._v("重绘(repaint)")]),v._v("\n当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此 损耗较少")]),v._v(" "),l("p",[l("strong",[v._v("回流(reflow)")]),v._v("\n当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。")]),v._v(" "),l("p",[v._v("此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。")]),v._v(" "),l("blockquote",[l("p",[v._v("触发回流的操作")])]),v._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[v._v("- 页面初次渲染\n- 浏览器窗口大小改变\n- 元素尺寸、位置、内容发生改变\n- 元素字体大小变化\n- 添加或者删除可见的 dom 元素\n- 激活 CSS 伪类（例如：:hover）\n")])])]),l("blockquote",[l("p",[v._v("回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。")])]),v._v(" "),l("p",[l("strong",[v._v("最佳实践")])]),v._v(" "),l("blockquote",[l("p",[v._v("css")])]),v._v(" "),l("ul",[l("li",[v._v("避免使用 table 布局")]),v._v(" "),l("li",[v._v("将动画效果应用到 position 属性为 absolute 或 fixed 的元素上")])]),v._v(" "),l("blockquote",[l("p",[v._v("javascript")])]),v._v(" "),l("ul",[l("li",[v._v("避免频繁操作样式，可汇总后统一 一次修改")]),v._v(" "),l("li",[v._v("尽量使用 class 进行样式修改")]),v._v(" "),l("li",[v._v("减少 dom 的增删次数，可使用 字符串 或者 documentFragment 一次性插入")]),v._v(" "),l("li",[v._v("极限优化时，修改样式可将其 display: none 后修改")]),v._v(" "),l("li",[v._v("避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 变量存住")])]),v._v(" "),l("h2",{attrs:{id:"存储"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#存储"}},[v._v("#")]),v._v(" 存储")]),v._v(" "),l("p",[v._v("对业务中的一些数据进行存储，通常可以分为 短暂性存储 和 持久性储存。")]),v._v(" "),l("p",[l("strong",[v._v("短暂性存储")]),v._v("\n只需要将数据存在内存中，只在运行时可用")]),v._v(" "),l("p",[l("strong",[v._v("持久性存储")])]),v._v(" "),l("ul",[l("li",[l("p",[v._v("浏览器:")]),v._v(" "),l("ul",[l("li",[v._v("cookie: 通常用于存储用户身份，登录状态等\n"),l("ul",[l("li",[v._v("http 中自动携带， 体积上限为 4K， 可自行设置过期时间")])])]),v._v(" "),l("li",[v._v("localStorage / sessionStorage: 长久储存/窗口关闭删除， 体积限制为 4~5M")]),v._v(" "),l("li",[v._v("indexDB")])])]),v._v(" "),l("li",[l("p",[v._v("服务器:")]),v._v(" "),l("ul",[l("li",[v._v("分布式缓存 redis")]),v._v(" "),l("li",[v._v("数据库")])])])]),v._v(" "),l("h2",{attrs:{id:"浏览器架构"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#浏览器架构"}},[v._v("#")]),v._v(" 浏览器架构")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("用户界面")])]),v._v(" "),l("li",[l("p",[v._v("主进程")])]),v._v(" "),l("li",[l("p",[v._v("内核")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("渲染引擎")])]),v._v(" "),l("li",[l("p",[v._v("JS 引擎")]),v._v(" "),l("ul",[l("li",[v._v("执行栈")])])]),v._v(" "),l("li",[l("p",[v._v("事件触发线程")]),v._v(" "),l("ul",[l("li",[v._v("消息队列\n"),l("ul",[l("li",[v._v("微任务")]),v._v(" "),l("li",[v._v("宏任务")])])])])]),v._v(" "),l("li",[l("p",[v._v("网络异步线程")])]),v._v(" "),l("li",[l("p",[v._v("定时器线程")])])])])]),v._v(" "),l("h2",{attrs:{id:"跨标签页通讯"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#跨标签页通讯"}},[v._v("#")]),v._v(" 跨标签页通讯")]),v._v(" "),l("p",[v._v("不同标签页间的通讯，本质原理就是去运用一些可以 共享的中间介质，因此比较常用的有以下方法:")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("通过父页面 window.open()和子页面 postMessage")])]),v._v(" "),l("li",[l("p",[v._v("异步下，通过 window.open('about: blank') 和 tab.location.href = '*'")])]),v._v(" "),l("li",[l("p",[v._v("设置同域下共享的 localStorage 与监听 window.onstorage")])]),v._v(" "),l("li",[l("p",[v._v("重复写入相同的值无法触发")])]),v._v(" "),l("li",[l("p",[v._v("会受到浏览器隐身模式等的限制")])]),v._v(" "),l("li",[l("p",[v._v("设置共享 cookie 与不断轮询脏检查(setInterval)")])]),v._v(" "),l("li",[l("p",[v._v("借助服务端或者中间层实现")])])]),v._v(" "),l("h2",{attrs:{id:"v8-垃圾回收机制"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#v8-垃圾回收机制"}},[v._v("#")]),v._v(" V8 垃圾回收机制")]),v._v(" "),l("p",[v._v("垃圾回收: 将内存中不再使用的数据进行清理，释放出内存空间。")]),v._v(" "),l("p",[v._v("V8 将内存分成 新生代空间 和 老生代空间。")]),v._v(" "),l("p",[l("strong",[v._v("新生代空间")]),v._v(":")]),v._v(" "),l("p",[v._v("用于存活较短的对象")]),v._v(" "),l("ul",[l("li",[v._v("又分成两个空间: from 空间 与 to 空间")]),v._v(" "),l("li",[v._v("Scavenge GC 算法: 当 from 空间被占满时，启动 GC 算法\n"),l("ul",[l("li",[v._v("存活的对象从 from space 转移到 to space")]),v._v(" "),l("li",[v._v("清空 from space")]),v._v(" "),l("li",[v._v("from space 与 to space 互换")]),v._v(" "),l("li",[v._v("完成一次新生代 GC")])])])]),v._v(" "),l("p",[l("strong",[v._v("老生代空间")]),v._v("\n用于存活时间较长的对象")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("从 新生代空间 转移到 老生代空间 的条件")]),v._v(" "),l("ul",[l("li",[v._v("经历过一次以上 Scavenge GC 的对象")]),v._v(" "),l("li",[v._v("当 to space 体积超过 25%")])])]),v._v(" "),l("li",[l("p",[v._v("标记清除算法: 标记存活的对象，未被标记的则被释放")]),v._v(" "),l("ul",[l("li",[v._v("增量标记: 小模块标记，在代码执行间隙执，GC 会影响性能")]),v._v(" "),l("li",[v._v("并发标记(最新技术): 不阻塞 js 执行")])])]),v._v(" "),l("li",[l("p",[v._v("压缩算法: 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 内存的碎片化")])])])])}),[],!1,null,null,null);_.default=i.exports}}]);