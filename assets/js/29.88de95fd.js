(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{425:function(t,n,a){"use strict";a.r(n);var e=a(55),l=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"javascript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[t._v("#")]),t._v(" JavaScript")]),t._v(" "),a("h2",{attrs:{id:"call、apply-执行效率"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call、apply-执行效率"}},[t._v("#")]),t._v(" call、apply 执行效率")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function callTest() { console.log(this); }\nfunction applyTest() { console.log(this); }\n\nconst obj = {};\n\ncallTest.call(obj, arg1, arg2, arg3);\napplyTest.apply(obj, [arg1, arg2, arg3]);\n")])])]),a("blockquote",[a("p",[t._v("call 和 apply 之间，call 的性能更好")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("applyTest.apply(obj, [arg1, arg2, arg3]);\n\nfunction apply() {\n    this.call(obj, [...arguments]);\n}\n")])])]),a("p",[t._v("其实在底层运行上，apply 在调用 apply 的时候，还需要对传入的第二个参数进行解构赋值。\n所以从运行的效率的角度上来说，call 少了一次解构赋值，运行效率会比 apply 会更高。")]),t._v(" "),a("blockquote",[a("p",[t._v("ES6 里面的 call 还能用解构来传参")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const f = function (a, b, c) {\n  console.log(a, b, c)\n}\nconst arr = [1, 2, 3]\nf.call(null, ...arr)\n")])])]),a("h2",{attrs:{id:"bind-两次-this-指向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bind-两次-this-指向"}},[t._v("#")]),t._v(" bind 两次 this 指向")]),t._v(" "),a("blockquote",[a("p",[t._v("bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。")])]),t._v(" "),a("p",[t._v("bind 方法与 call / apply 最大的不同就是前者返回一个绑定上下文的函数，而后两者是直接执行了函数。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let value = 2;\nlet foo = {\n  value: 1\n};\nfunction bar(name, age) {\n  return {\n    value: this.value,\n    name: name,\n    age: age\n  }\n};\n\n// 直接执行了函数\nbar.call(foo, "Jack", 20);\n// {value: 1, name: "Jack", age: 20}\n\n// 返回一个函数\nlet bind1 = bar.bind(foo, "Jack", 20);\nbind1();\n// {value: 1, name: "Jack", age: 20}\n\n// 返回一个函数\nlet bind2 = bar.bind(foo, "Jack");\nbind2(20);\n// {value: 1, name: "Jack", age: 20}\n')])])]),a("p",[t._v("bind 有如下特性：")]),t._v(" "),a("ul",[a("li",[t._v("指定 this")]),t._v(" "),a("li",[t._v("传入参数")]),t._v(" "),a("li",[t._v("返回一个函数")]),t._v(" "),a("li",[t._v("柯里化")])]),t._v(" "),a("p",[a("strong",[t._v("模拟实现 bind")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('Function.prototype.bind = function (context) {\n  // 调用 bind 的不是函数，需要抛出异常\n  if (typeof this !== "function") {\n    throw new Error("Function.prototype.bind - what is trying to be bound is not callable");\n  }\n\n  // this 指向调用者\n  var self = this;\n\n  // 实现第2点：第1个参数是指定的this,只截取第1个之后的参数\n  var args = Array.prototype.slice.call(arguments, 1);\n\n  // 实现第3点：返回一个函数\n  return function () {\n    // 实现第4点：arguments是指bind返回的函数传入的参数\n    // 即 return function 的参数\n    var bindArgs = Array.prototype.slice.call(arguments);\n    // 实现第1点\n    return self.apply( context, args.concat(bindArgs) );\n  }\n}\n')])])]),a("p",[t._v("在第一次 bind 完 this 就已经确定，返回了一个函数出去，这个函数体内不存在 this 问题,后续无论 bind 多少次，this 都指向第一次 bind 传入的 context，但是后面 bind 再传入的参数会生效。")]),t._v(" "),a("h2",{attrs:{id:"函数柯里化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数柯里化"}},[t._v("#")]),t._v(" 函数柯里化")]),t._v(" "),a("p",[t._v("柯里化是将 f(a,b,c) 可以被以 f(a)(b)(c) 的形式被调用的转化")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var add = function(x) {\n  return function(y) {\n    return x + y;\n  };\n};\n\nvar increment = add(1);\nvar addTen = add(10);\n\nincrement(2);   // 3\n\naddTen(2);      // 12\n\nadd(1)(2);      // 3\n")])])]),a("h2",{attrs:{id:"数据类型判断"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据类型判断"}},[t._v("#")]),t._v(" 数据类型判断")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("instanceof")]),t._v(" "),a("blockquote",[a("p",[t._v("instanceof 是用来判断 A 是否为 B 的实例\n只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型")])])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("[] instanceof Array; // true\n{} instanceof Object;// true\nnew Date() instanceof Date;// true\n\nfunction Person(){};\nnew Person() instanceof Person;\n\n[] instanceof Object; // true\nnew Date() instanceof Object;// true\nnew Person instanceof Object;// true\n")])])]),a("ul",[a("li",[a("p",[t._v("typeof\ntypeof null，返回的是 object\ntypeof 函数，返回的是 function\ntypeof 对象实例，返回的是 object，这里注意，除了函数，其他的实例应该都返回的 object")])]),t._v(" "),a("li",[a("p",[t._v("Object.prototype.toString.call")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Object.prototype.toString.call('') ;                // [object String]\nObject.prototype.toString.call(1) ;                 // [object Number]\nObject.prototype.toString.call(true) ;              // [object Boolean]\nObject.prototype.toString.call(Symbol());           //[object Symbol]\nObject.prototype.toString.call(undefined) ;         // [object Undefined]\nObject.prototype.toString.call(null) ;              // [object Null]\nObject.prototype.toString.call(new Function()) ;    // [object Function]\nObject.prototype.toString.call(new Date()) ;        // [object Date]\nObject.prototype.toString.call([]) ;                // [object Array]\nObject.prototype.toString.call(new RegExp()) ;      // [object RegExp]\nObject.prototype.toString.call(new Error()) ;       // [object Error]\nObject.prototype.toString.call(document) ;          // [object HTMLDocument]\nObject.prototype.toString.call(window) ;            //[object global] window 是全局对象 global 的引用\n\n")])])])])}),[],!1,null,null,null);n.default=l.exports}}]);