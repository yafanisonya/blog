(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{424:function(t,e,a){"use strict";a.r(e);var n=a(55),s=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" Vue")]),t._v(" "),a("h2",{attrs:{id:"组件内部强制刷新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件内部强制刷新"}},[t._v("#")]),t._v(" 组件内部强制刷新")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("刷新整个页面 this.$router.go(0)")])]),t._v(" "),a("li",[a("p",[t._v("使用 v-if 标记")]),t._v(" "),a("blockquote",[a("p",[t._v("当 v-if 的值发生变化时，组件都会被重新渲染一遍")])])]),t._v(" "),a("li",[a("p",[t._v("使用内置的 forceUpdate 方法")]),t._v(" "),a("blockquote",[a("p",[t._v("调用强制更新方法 this.$forceUpdate()会更新视图和数据，触发 updated 生命周期")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<template>\n  <button @click="reflush()">刷新组件</button>\n</template>\n\n<script>\nexport default {\n  methods: {\n    reflush () {\n      this.$forceUpdate()\n    }\n  }\n}\n<\/script>\n')])])])]),t._v(" "),a("li",[a("p",[t._v("使用 key-changing 优化组件")]),t._v(" "),a("blockquote",[a("p",[t._v("vue 使用 key 标记组件身份，当 key 改变时就是释放原始组件，重新加载新的组件")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<template>\n  <div>\n    <span :key="key"></span>\n  </div>\n</template>\n\n<script>\nexport default {\n  data () {\n    return {\n      key: 0\n    }\n  },\n  methods: {\n    handleUpdateClick () {\n      this.key += 1\n    }\n  }\n}\n<\/script>\n')])])])])]),t._v(" "),a("h2",{attrs:{id:"vue-实现过渡动画"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-实现过渡动画"}},[t._v("#")]),t._v(" Vue 实现过渡动画")]),t._v(" "),a("p",[t._v("Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡")]),t._v(" "),a("ul",[a("li",[t._v("条件渲染 (使用 v-if)")]),t._v(" "),a("li",[t._v("条件展示 (使用 v-show)")]),t._v(" "),a("li",[t._v("动态组件")]),t._v(" "),a("li",[t._v("组件根节点")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<div id="demo">\n  <button v-on:click="show = !show">\n    Toggle\n  </button>\n  <transition name="fade">\n    <p v-if="show">hello</p>\n  </transition>\n</div>\n\nnew Vue({\n  el: \'#demo\',\n  data: {\n    show: true\n  }\n})\n')])])]),a("h2",{attrs:{id:"自定义指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义指令"}},[t._v("#")]),t._v(" 自定义指令")]),t._v(" "),a("ul",[a("li",[t._v("通过 Vue.directive() 函数注册一个全局的指令")]),t._v(" "),a("li",[t._v("通过组件的 directives 属性，对该组件添加一个局部的指令")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 注册一个全局自定义指令 `v-focus`\nVue.directive('focus', {\n  // 当被绑定的元素插入到 DOM 中时……\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n\ndirectives: {\n  focus: {\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n\n<input v-focus>\n\n")])])]),a("p",[a("strong",[t._v("钩子函数")])]),t._v(" "),a("ul",[a("li",[t._v("bind：只调用一次，指令第一次绑定到元素时调用")]),t._v(" "),a("li",[t._v("inserted：被绑定元素插入父节点时调用")]),t._v(" "),a("li",[t._v("update：所在组件的 VNode 更新时调用。")]),t._v(" "),a("li",[t._v("componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用")]),t._v(" "),a("li",[t._v("unbind：只调用一次，指令与元素解绑时调用")])]),t._v(" "),a("h2",{attrs:{id:"vue-中重置-data-的数据为初始状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-中重置-data-的数据为初始状态"}},[t._v("#")]),t._v(" Vue 中重置 data 的数据为初始状态")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("使用 Object.assign(target, ...sources)")]),t._v(" "),a("blockquote",[a("p",[t._v("第一个参数是目标对象，第二个参数是源对象，就是将源对象属性复制到目标对象，返回目标对象")])])]),t._v(" "),a("li",[a("p",[t._v("this.$data 获取当前状态下的 data")])]),t._v(" "),a("li",[a("p",[t._v("this.$options.data() 获取该组件初始状态下的 data")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 将初始状态的 data 复制到当前状态的 data\nObject.assign(this.$data, this.$options.data())\n\n// 重置 data 中的某一个对象或者属性：\nthis.form = this.$options.data().form\n")])])]),a("h2",{attrs:{id:"vue、-react-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue、-react-区别"}},[t._v("#")]),t._v(" Vue、 React 区别")]),t._v(" "),a("p",[a("strong",[t._v("数据流")])]),t._v(" "),a("ul",[a("li",[t._v("React 推崇函数式编程（纯组件），数据不可变以及单向数据流")]),t._v(" "),a("li",[t._v("Vue 是响应式的，也就是基于是数据可变的，当属性变化的时候，响应式的更新对应的虚拟 dom")])]),t._v(" "),a("p",[a("strong",[t._v("响应式原理")])]),t._v(" "),a("ul",[a("li",[t._v("React: setState,当数据改变时，以组件为根目录，默认全部重新渲染")]),t._v(" "),a("li",[t._v("Vue: Vue 依赖收集，当数据改变时，自动找到引用组件重新渲染")])]),t._v(" "),a("p",[a("strong",[t._v("组件写法差异")])]),t._v(" "),a("ul",[a("li",[t._v("React: JSX + inline style")]),t._v(" "),a("li",[t._v("Vue: template 的单文件组件")])])])}),[],!1,null,null,null);e.default=s.exports}}]);