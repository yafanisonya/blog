(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{420:function(n,e,o){"use strict";o.r(e);var t=o(55),s=Object(t.a)({},(function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("h3",{attrs:{id:"异步编程"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#异步编程"}},[n._v("#")]),n._v(" 异步编程")]),n._v(" "),o("h4",{attrs:{id:"同步模式"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#同步模式"}},[n._v("#")]),n._v(" 同步模式")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("console.log('global start')\n\nfunction bar(){\n  console.log('bar task')\n}\n\nfunction foo(){\n  console.log('foo task')\n  bar()\n}\n\nfoo()\n\nconsole.log('global end')\n\n// 输出\nglobal begin\nfoo task\nbar task\nglobal end\n")])])]),o("h4",{attrs:{id:"异步模式"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#异步模式"}},[n._v("#")]),n._v(" 异步模式")]),n._v(" "),o("p",[o("img",{attrs:{src:"https://i.imgur.com/KEeOg6m.png",alt:"异步模式"}})]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("console.log('global begin')\n\nsetTimeout(function timer1(){\n  console.log('timer1 invoke')\n},1800)\n\nsetTimeout(function timer2(){\n  console.log('timer2 invoke')\n\n  setTimeout(function inner(){\n    console.log('inner invoke')\n  },1000)\n})\n\nconsole.log('global end')\n\n// 输出\nglobal begin\nglobal end\ntimer2 invoke\ntimer1 invoke\ninner invoke\n")])])]),o("h4",{attrs:{id:"回调函数"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#回调函数"}},[n._v("#")]),n._v(" 回调函数")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("function foo(callback){\n  setTimeout(function(){\n    callback()\n  },3000)\n}\n\nfoo(function(){\n  console.log('回调函数')\n  console.log('异步任务结束后执行此函数')\n})\n")])])]),o("h4",{attrs:{id:"promise"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[n._v("#")]),n._v(" Promise")]),n._v(" "),o("p",[o("img",{attrs:{src:"https://i.imgur.com/FRD0dFV.png",alt:"Promise"}})]),n._v(" "),o("h5",{attrs:{id:"基本示例"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#基本示例"}},[n._v("#")]),n._v(" 基本示例")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("const promise = new Promise(function (reslove, reject){\n  resolve(100)\n  reject(new Error('promise rejected'))\n})\n\npromise.then(function (value){\n  console.log('resolved ===>>> ', value)\n}, function (error){\n  console.log('rejected ===>>>', error)\n})\n")])])]),o("h5",{attrs:{id:"封装-ajax"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#封装-ajax"}},[n._v("#")]),n._v(" 封装 AJAX")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("function ajax(url){\n  return new Promise(function (resolve, reject) {\n    var xhr = new XMLHttpRequest()\n    xhr.open('GET',url)\n    xhr.responseType = 'json'\n    xhr.onload = function (){\n      if(this.status === 200){\n        resolve(this.response)\n      } else {\n        reject(new Error(this.statusText))\n      }\n    }\n    xhr.send()\n  })\n}\n\najax('/api/first.json').then( function (res){\n  console.log(res)\n}, function (error){\n  console.log(error)\n})\n")])])]),o("h5",{attrs:{id:"链式调用"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#链式调用"}},[n._v("#")]),n._v(" 链式调用")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("ajax('/api/users.json')\n  .then(function(value){\n    console.log('first === >>>')\n  })\n  .then(function(value){\n    console.log('second === >>>')\n  })\n")])])]),o("h5",{attrs:{id:"异常处理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#异常处理"}},[n._v("#")]),n._v(" 异常处理")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("// 因为 Promise 链条上的任何一个异常都会被一直向后传递，直至捕获\n// 分开注册的 onRejected 相当于给整个 Promise 链条注册失败回调\n\najax('/api/users.json')\n  .then(function onFulfilled(value){\n    console.log('onFulfilled === >>>', value)\n  })\n  .catch(function onRejected(error){\n    console.log('onRejected === >>>', error)\n  })\n\n // then(onRejected) 实际上就相当于 then(undefined, onRejected)\n\n  ajax('/api/users.json')\n    .then(function onFulfilled(value){\n      console.log('onFulfilled === >>>', value)\n    })\n    .then(undefined, function onRejected(error){\n      console.log('onRejected === >>>', error)\n    })\n\n // 同时注册的 onRejected 只是给当前 Promise 对象注册的失败回调， 它只能捕获到当前 Promise 对象的异常\n\n  ajax('/api/users.json')\n    .then(function onFulfilled(value){\n      console.log('onFulfilled === >>>', value)\n    }, function onRejected(error){\n      console.log('onRejected === >>>', error)\n    })\n")])])]),o("h5",{attrs:{id:"all、race"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#all、race"}},[n._v("#")]),n._v(" All、Race")]),n._v(" "),o("ul",[o("li",[n._v("Promise.all()中的 Promise 全部执行通过才认为是成功，否则认为是失败；")]),n._v(" "),o("li",[n._v("Promise.race()中的 Promise 中第一个执行完毕的是通过，则认为成功，如果第一个执行完毕的 Promise 是拒绝，则认为失败；")])]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("var promise = Promise.all([\n  ajax('/api/users.json'),\n  ajax('/api/posts.json')\n])\n\n// Promise.race 实现超时控制\nconst request = ajax('/api/posts.json')\nconst timeout = new Promise((resolve, reject) => {\n  setTimeout(() => reject(new Error('timeout === >>>')), 500)\n})\n\nPromise.race([\n  request, timeout\n])\n.then(value =>{\n  console.log(value)\n})\n.catch(error =>{\n  console.log(error)\n})\n")])])]),o("h5",{attrs:{id:"执行顺序"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#执行顺序"}},[n._v("#")]),n._v(" 执行顺序")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("// 微任务\nconsole.log('global start')\n\n// setTimeout 的回调是 宏任务， 进入回调队列排队\nsetTimeout(() => {\n  console.log('setTimeout')\n}, 0)\n\n// Promise 的回调是 微任务， 本轮调用末尾直接执行\nPromise.resolve()\n  .then(() => {\n    console.log('promise')\n  }）\n  .then(() => {\n    console.log('promise 2')\n  })\n  .then(() => {\n    console.log('promise 3')\n  })\n\nconsole.log('global end')\n\n// 输出\n// global start, global end, promise, promise 2, promise 3, setTimeout\n")])])]),o("h4",{attrs:{id:"generator"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#generator"}},[n._v("#")]),n._v(" Generator")]),n._v(" "),o("ul",[o("li",[n._v("Generator 函数可以暂停执行， 在函数名前要加星号")]),n._v(" "),o("li",[n._v("value 是 yield 语句后面表达式的值，表示当前阶段的值；")]),n._v(" "),o("li",[n._v("done 是布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段")])]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("// 生成器函数\nfunction * foo(){\n  console.log('start === >>>')\n\n  try{\n    const res = yield 'foo'\n    console.log(res)\n  } catch(e){\n    console.log(e)\n  }\n}\n\n// 执行函数不会返回结果，返回的是指针对象\nconst generator = foo()\n\n// 调用指针的 next 方法，会移动内部指针指向第一个 yield 语句\nconst result = generator.next()\nconsole.log(result)  //  { value: 'foo', done: false }\n\n// next方法带有参数，参数传入 Generator 函数，作为上个阶段异步任务的返回结果\ngenerator.next('bar') // bar\n\n// 使用指针对象的 throw 方法抛出错误， 可以被 try...catch 代码块捕获\ngenerator.throw(new Error('Generator error'))\n")])])]),o("h4",{attrs:{id:"async、await"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#async、await"}},[n._v("#")]),n._v(" Async、Await")]),n._v(" "),o("ul",[o("li",[n._v("async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数")]),n._v(" "),o("li",[n._v("当函数执行时，一旦遇到 await 就会先返回")]),n._v(" "),o("li",[n._v("等到触发的异步操作完成，再执行函数体内后面的语句")]),n._v(" "),o("li",[n._v("await 命令只能用在 async 函数之中，如果用在普通函数，就会报错")])]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("async function main(){\n  try{\n    const users = await ajax('/api/users.json')\n    console.log(users)\n\n    const posts = await ajax('/api/posts.json')\n    console.log(posts)\n\n    const urls = await ajax('/api/urls.json')\n    console.log(urls)\n  } catch (e) {\n    console.log(e)\n  }\n}\n\nconst promise = main()\n\npromise.then(() => {\n  console.log('all completed')\n})\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);